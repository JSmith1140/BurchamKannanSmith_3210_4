<!DOCTYPE html>
<html>
<head>
    <title>BurchamKannanSmith_3210_4</title>
    <script src="https://cdn.jsdelivr.net/gh/josephg/noisejs/perlin.js"></script>
</head>
<body>

    <canvas id="myCanvas" width="1200" height="900"></canvas>

    <script type="module">
        import * as THREE from 'three';

        var scene = new THREE.Scene();
        var camera = new THREE.PerspectiveCamera(35, window.innerWidth / window.innerHeight, .1, 3000);
        camera.position.set(0, 20, 100); 
        camera.lookAt(new THREE.Vector3(0.0,0.0,0.0));
        scene.add(camera);

        var renderer = new THREE.WebGLRenderer({canvas: myCanvas, antialias: true});
        renderer.setClearColor(0x87CEEB);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);

        // Initialize Perlin Noise
        noise.seed(Math.random());

        // Terrain dimensions
        const terrainWidth = 1000;
        const terrainHeight = 1000;
        const terrainSegments = 500;
        const terrainScale = 10;

        // Function to generate terrain using Perlin noise
        function generateTerrain() {
            const geometry = new THREE.PlaneGeometry(terrainWidth, terrainHeight, terrainSegments, terrainSegments);
            geometry.rotateX(-Math.PI / 2); // Rotate terrain

            // Apply Perlin noise to each vertex
            for (let i = 0; i < geometry.attributes.position.count; i++) {
                const x = geometry.attributes.position.getX(i);
                const z = geometry.attributes.position.getZ(i);

                // Use Perlin noise to alter the height based on x and z coordinates
                const noiseValue = noise.perlin2(x / terrainScale, z / terrainScale); 
                const height = noiseValue * terrainScale; 

                geometry.attributes.position.setY(i, height);
            }
            geometry.computeVertexNormals();

             return geometry;
         }

        // Finds terrain height for the camera bumpy effect
        function getterrainBump(x, z) {
            const noiseX = x / terrainScale;
            const noiseZ = z / terrainScale;
            return noise.perlin2(noiseX, noiseZ) * terrainScale;
        }

        // Create the Texture for terrain
        const textureLoader = new THREE.TextureLoader();
        const terrainTexture = textureLoader.load('GrassTexture.jpg'); // GrassTexture jpg for terrain
        terrainTexture.wrapS = terrainTexture.wrapT = THREE.RepeatWrapping; 
        terrainTexture.repeat.set(10, 10); 

        // Create terrain mesh
        const terrainGeometry = generateTerrain();
        const terrainMaterial = new THREE.MeshStandardMaterial({ 
            map: terrainTexture, 
            flatShading: true,
        });
        const terrain = new THREE.Mesh(terrainGeometry, terrainMaterial);
        scene.add(terrain); // add terrain to scene

        // Add Ambient Light to the scene
        const ambientLight = new THREE.AmbientLight(0xFFFFFF, 1); // white ambient light
        scene.add(ambientLight);

        // Spotlight for User Flashlight
        const flashlightColor = 0xFFFF00; // yellow color for Flashlight
        const flashlightIntensity = 10000;
        const flashlight = new THREE.SpotLight(flashlightColor, flashlightIntensity);
        flashlight.position.set(camera.position.x, camera.position.y, camera.position.z);
        flashlight.distance = 200; // flashlight distance
        flashlight.angle = Math.PI / 6; // flashlight angle for flashlight circle 
        flashlight.penumbra = 0.5; // keeps the edges of flashlight circle softer
        scene.add(flashlight);

        // Moving directions
        const speed = 0.5; // Walking speed
        let isMovingForward = false;
        let isMovingBackward = false;
        let isMovingLeft = false;
        let isMovingRight = false;

        function updateCameraPosition() {
            if (isMovingForward) camera.position.z -= speed;
            if (isMovingBackward) camera.position.z += speed;
            if (isMovingLeft) camera.position.x -= speed;
            if (isMovingRight) camera.position.x += speed;

            // moves camera up and down based on terrain height
            const terrainHeight = getterrainBump(camera.position.x, camera.position.z);

            camera.position.y = terrainHeight + 25; // camera is higher up to emulate a person

            // copy flashlight position to camera position every frame
            flashlight.position.copy(camera.position);
            flashlight.target.position.set(
                camera.position.x + camera.getWorldDirection(new THREE.Vector3()).x * 10,
                camera.position.y - 5,
                camera.position.z + camera.getWorldDirection(new THREE.Vector3()).z * 10
            );
            flashlight.target.updateMatrixWorld();
        }

        // Turn key to true when pressed down
        window.addEventListener("keydown", (event) => {
            if (event.key === "w") isMovingForward = true;
            if (event.key === "s") isMovingBackward = true;
            if (event.key === "a") isMovingLeft = true;
            if (event.key === "d") isMovingRight = true;
        });

        // Turn key to false when pressed up
        window.addEventListener("keyup", (event) => {
            if (event.key === "w") isMovingForward = false;
            if (event.key === "s") isMovingBackward = false;
            if (event.key === "a") isMovingLeft = false;
            if (event.key === "d") isMovingRight = false;
            if (event.key === "f") {
                flashlightOn = !flashlightOn; // Toggle flashlight
                flashlight.visible = flashlightOn;
            }
        });

        flashlight.visible = false; // start with flashlight off
        let flashlightOn = false;
        // Key handler function
        function keyhandler(e) {
            switch (e.keyCode) { 
                case 70: // 'F' Key
                        flashlightOn = !flashlightOn; // Toggle flashlight
                        flashlight.visible = flashlightOn; 
                    break;
            }
        }

        // Code for Sun
        const color = 0xFFFFFF;
        const intensity = 3;
        const sun = new THREE.DirectionalLight(color, intensity);
        sun.position.set(0, 10, 0);
        sun.target.position.set(-5, 0, 0);
        scene.add(sun); // Add sun to the scene
        scene.add(sun.target); // Add the light target to the scene as well if needed

        function deltaTime() {
            var angle = 30 * Math.PI/180;
            var time = 0.01;
            var deltaX = sun.position.x + Math.cos(angle) * time;
            var deltaY = sun.position.y + Math.sin(angle) * time;
            sun.position.set(deltaX, deltaY, sun.position.z);

            var cycle = (deltaY + 15)/20;
            var sunColor = new THREE.Color();
            color.setHSL(0.1 * cycle, 1, 0.5);
            sun.sunColor = sunColor;

            requestAnimationFrame(deltaTime);
        }

        function animate() {
            requestAnimationFrame(animate);

            updateCameraPosition();
            
            renderer.render(scene, camera); // render the scene and camera
        }

        animate(); // call animate function
    </script>
</body>
</html>
